공유 변수에 대한 접근을 atomic하게 처리하기 위해 사용하는 것이 lock이다. 
lock을 크게 전체 함수에 잡을 수 있고, 작게는 코드 한줄만 lock을 사용할 수 있다.
lock은 멀티 쓰레드 환경에서는 많은 오버헤드가 발생하므로 트레이드 오프 측면에서 많은 생각을 하게 만든다. 
lock을 평가하는 요소로는 fairness, performance가 있고 모든 쓰레드가 공평하게 사용해야 하며, 멀티 쓰레드 환경을 최대한 활용하는 
lock을 사용해야 한다. 

Interrupt를 이용한 lock은 단순히 생각한다면 이상적인 lock이다. 특정 함수가 실행될때 인터럽트가 발생하지 않아 오직 그 코드만 실행
할 수 있다. 하지만 모든 interrupt를 차단하므로 코드가 실행할때 kernel이 동작 하지 못할 수 도 있다. interrupt 코드는 오직 커널에서만 
실행 할 수 있으며, 멀티 코어 환경에서는 잘 작동하지 않는다. 그 이유는 코어마다 인터럽트 비트가 있어서 코어 하나의 인터럽트를 막아도 인터럽트는 발생한다.

현재는 Test-And-Set이라는 atomic한 함수(및 어셈블리 명령어)를 이용하여 좀더 쉽게 lock을 구현 할 수 있다. 
기존 spin-lock의 문제점이었던 flag 값이 변하는 순간 다른 쓰레드가 접근할 경우 두개다 데드락에 걸리는 문제점이 있다. 
하지만 Test-And_Set을 이용한다면 쉽게 lock을 구현 할 수 있다. 하지만 단순한 스핀락 소스코드는 모든 쓰레드에게 공평함을 부여하지 않는다.

Compare-And-Swap을 이용하면 모든 쓰레드 들이 공평하게 순서대로 공유 자원에 접근 할 수 있다. 쓰레드마다 기대값을 설정하고 해당 기대 값일 경우에만 
공유 자원에 접근 함으로써 차례대로 공유자원에 접근 할 수 있다. Test-And-Set의 발전형이라 할 수 있다. 

위의 방법은 모두 spin-lock을 이용한 방법으로 모든 쓰레드가 접근할 수 없어 CPU의 활용을 제대로 하지 못한다. 그렇다면 lock때문에 공유자원에 
접근하지 못하는 쓰레드는 cpu를 사용하지 않고 다른 프로세스가 작동하게 하면 될것같다.
공유자원에 접근하지 못한 쓰레드는 sleep을 하고 다시 자신의 차례가 왔을때 또 다시 lock이 걸려있다면 이건 공평치 못한 경우 일 것이다. 
무조건 slepp을 하는 것이 아니라 하나의 큐를 두어 다음 차레의 쓰레드를 누가 쓸지 정해서 멀티 코어의 활용을 높이고, 쓸데 없는 코어 활용을 줄 일 수 있다.
그렇지만 이 하나의 큐또한 공유 자원이므로 이 자원에 접근할때에도 lock이 필요하다. 이만큼 코드가 늘고 공평성과 성능을 향상 시킬 수록 
세세하게 잘 작동하지만 그만큼 복잡도가 올라간다. 